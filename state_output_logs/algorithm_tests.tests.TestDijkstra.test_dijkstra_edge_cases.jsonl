{'line_number': 27, 'code_line': "single_node_graph = {'A': {}}", 'variables': {}, 'file': 'tests'}
{'line_number': 28, 'code_line': "distances, paths = dijkstra(single_node_graph, 'A')", 'variables': {'single_node_graph': "{'A': {}}"}, 'file': 'tests'}
{'line_number': 4, 'code_line': "distances = {node: float('infinity') for node in graph}", 'variables': {'graph': "{'A': {}}", 'start': "'A'"}, 'file': 'test1'}
{'line_number': 5, 'code_line': 'distances[start] = 0', 'variables': {'graph': "{'A': {}}", 'start': "'A'", 'distances': "{'A': inf}"}, 'file': 'test1'}
{'line_number': 7, 'code_line': 'pq = [(0, start)]', 'variables': {'graph': "{'A': {}}", 'start': "'A'", 'distances': "{'A': 0}"}, 'file': 'test1'}
{'line_number': 8, 'code_line': 'previous_nodes = {node: None for node in graph}', 'variables': {'graph': "{'A': {}}", 'start': "'A'", 'distances': "{'A': 0}", 'pq': "[(0, 'A')]"}, 'file': 'test1'}
{'line_number': 10, 'code_line': 'while pq:\n    current_distance, current_node = heapq.heappop(pq)\n    if current_distance > distances[current_node]:\n        continue\n    for neighbor, weight in graph[current_node].items():\n        distance = current_distance + weight\n        if distance < distances[neighbor]:\n            distances[neighbor] = distance\n            previous_nodes[neighbor] = current_node\n            heapq.heappush(pq, (distance, neighbor))', 'variables': {'graph': "{'A': {}}", 'start': "'A'", 'distances': "{'A': 0}", 'pq': "[(0, 'A')]", 'previous_nodes': "{'A': None}"}, 'file': 'test1'}
{'line_number': 11, 'code_line': 'current_distance, current_node = heapq.heappop(pq)', 'variables': {'graph': "{'A': {}}", 'start': "'A'", 'distances': "{'A': 0}", 'pq': "[(0, 'A')]", 'previous_nodes': "{'A': None}"}, 'file': 'test1'}
{'line_number': 13, 'code_line': 'if current_distance > distances[current_node]:\n    continue', 'variables': {'graph': "{'A': {}}", 'start': "'A'", 'distances': "{'A': 0}", 'pq': '[]', 'previous_nodes': "{'A': None}", 'current_distance': '0', 'current_node': "'A'"}, 'file': 'test1'}
{'line_number': 16, 'code_line': 'for neighbor, weight in graph[current_node].items():\n    distance = current_distance + weight\n    if distance < distances[neighbor]:\n        distances[neighbor] = distance\n        previous_nodes[neighbor] = current_node\n        heapq.heappush(pq, (distance, neighbor))', 'variables': {'graph': "{'A': {}}", 'start': "'A'", 'distances': "{'A': 0}", 'pq': '[]', 'previous_nodes': "{'A': None}", 'current_distance': '0', 'current_node': "'A'"}, 'file': 'test1'}
{'line_number': 24, 'code_line': 'return (distances, previous_nodes)', 'variables': {'graph': "{'A': {}}", 'start': "'A'", 'distances': "{'A': 0}", 'pq': '[]', 'previous_nodes': "{'A': None}", 'current_distance': '0', 'current_node': "'A'"}, 'file': 'test1'}
{'line_number': 29, 'code_line': "self.assertEqual(distances['A'], 0)", 'variables': {'single_node_graph': "{'A': {}}", 'distances': "{'A': 0}", 'paths': "{'A': None}"}, 'file': 'tests'}
{'line_number': 32, 'code_line': "disconnected_graph = {'A': {}, 'B': {}, 'C': {}}", 'variables': {'single_node_graph': "{'A': {}}", 'distances': "{'A': 0}", 'paths': "{'A': None}"}, 'file': 'tests'}
{'line_number': 37, 'code_line': "distances, paths = dijkstra(disconnected_graph, 'A')", 'variables': {'single_node_graph': "{'A': {}}", 'distances': "{'A': 0}", 'paths': "{'A': None}", 'disconnected_graph': "{'A': {}, 'B': {}, 'C': {}}"}, 'file': 'tests'}
{'line_number': 4, 'code_line': "distances = {node: float('infinity') for node in graph}", 'variables': {'graph': "{'A': {}, 'B': {}, 'C': {}}", 'start': "'A'"}, 'file': 'test1'}
{'line_number': 5, 'code_line': 'distances[start] = 0', 'variables': {'graph': "{'A': {}, 'B': {}, 'C': {}}", 'start': "'A'", 'distances': "{'A': inf, 'B': inf, 'C': inf}"}, 'file': 'test1'}
{'line_number': 7, 'code_line': 'pq = [(0, start)]', 'variables': {'graph': "{'A': {}, 'B': {}, 'C': {}}", 'start': "'A'", 'distances': "{'A': 0, 'B': inf, 'C': inf}"}, 'file': 'test1'}
{'line_number': 8, 'code_line': 'previous_nodes = {node: None for node in graph}', 'variables': {'graph': "{'A': {}, 'B': {}, 'C': {}}", 'start': "'A'", 'distances': "{'A': 0, 'B': inf, 'C': inf}", 'pq': "[(0, 'A')]"}, 'file': 'test1'}
{'line_number': 10, 'code_line': 'while pq:\n    current_distance, current_node = heapq.heappop(pq)\n    if current_distance > distances[current_node]:\n        continue\n    for neighbor, weight in graph[current_node].items():\n        distance = current_distance + weight\n        if distance < distances[neighbor]:\n            distances[neighbor] = distance\n            previous_nodes[neighbor] = current_node\n            heapq.heappush(pq, (distance, neighbor))', 'variables': {'graph': "{'A': {}, 'B': {}, 'C': {}}", 'start': "'A'", 'distances': "{'A': 0, 'B': inf, 'C': inf}", 'pq': "[(0, 'A')]", 'previous_nodes': "{'A': None, 'B': None, 'C': None}"}, 'file': 'test1'}
{'line_number': 11, 'code_line': 'current_distance, current_node = heapq.heappop(pq)', 'variables': {'graph': "{'A': {}, 'B': {}, 'C': {}}", 'start': "'A'", 'distances': "{'A': 0, 'B': inf, 'C': inf}", 'pq': "[(0, 'A')]", 'previous_nodes': "{'A': None, 'B': None, 'C': None}"}, 'file': 'test1'}
{'line_number': 13, 'code_line': 'if current_distance > distances[current_node]:\n    continue', 'variables': {'graph': "{'A': {}, 'B': {}, 'C': {}}", 'start': "'A'", 'distances': "{'A': 0, 'B': inf, 'C': inf}", 'pq': '[]', 'previous_nodes': "{'A': None, 'B': None, 'C': None}", 'current_distance': '0', 'current_node': "'A'"}, 'file': 'test1'}
{'line_number': 16, 'code_line': 'for neighbor, weight in graph[current_node].items():\n    distance = current_distance + weight\n    if distance < distances[neighbor]:\n        distances[neighbor] = distance\n        previous_nodes[neighbor] = current_node\n        heapq.heappush(pq, (distance, neighbor))', 'variables': {'graph': "{'A': {}, 'B': {}, 'C': {}}", 'start': "'A'", 'distances': "{'A': 0, 'B': inf, 'C': inf}", 'pq': '[]', 'previous_nodes': "{'A': None, 'B': None, 'C': None}", 'current_distance': '0', 'current_node': "'A'"}, 'file': 'test1'}
{'line_number': 24, 'code_line': 'return (distances, previous_nodes)', 'variables': {'graph': "{'A': {}, 'B': {}, 'C': {}}", 'start': "'A'", 'distances': "{'A': 0, 'B': inf, 'C': inf}", 'pq': '[]', 'previous_nodes': "{'A': None, 'B': None, 'C': None}", 'current_distance': '0', 'current_node': "'A'"}, 'file': 'test1'}
{'line_number': 38, 'code_line': "for node in disconnected_graph:\n    self.assertEqual(distances[node], 0 if node == 'A' else float('infinity'))", 'variables': {'single_node_graph': "{'A': {}}", 'distances': "{'A': 0, 'B': inf, 'C': inf}", 'paths': "{'A': None, 'B': None, 'C': None}", 'disconnected_graph': "{'A': {}, 'B': {}, 'C': {}}"}, 'file': 'tests'}
{'line_number': 39, 'code_line': "self.assertEqual(distances[node], 0 if node == 'A' else float('infinity'))", 'variables': {'single_node_graph': "{'A': {}}", 'distances': "{'A': 0, 'B': inf, 'C': inf}", 'paths': "{'A': None, 'B': None, 'C': None}", 'disconnected_graph': "{'A': {}, 'B': {}, 'C': {}}", 'node': "'A'"}, 'file': 'tests'}
{'line_number': 39, 'code_line': "self.assertEqual(distances[node], 0 if node == 'A' else float('infinity'))", 'variables': {'single_node_graph': "{'A': {}}", 'distances': "{'A': 0, 'B': inf, 'C': inf}", 'paths': "{'A': None, 'B': None, 'C': None}", 'disconnected_graph': "{'A': {}, 'B': {}, 'C': {}}", 'node': "'B'"}, 'file': 'tests'}
{'line_number': 39, 'code_line': "self.assertEqual(distances[node], 0 if node == 'A' else float('infinity'))", 'variables': {'single_node_graph': "{'A': {}}", 'distances': "{'A': 0, 'B': inf, 'C': inf}", 'paths': "{'A': None, 'B': None, 'C': None}", 'disconnected_graph': "{'A': {}, 'B': {}, 'C': {}}", 'node': "'C'"}, 'file': 'tests'}
